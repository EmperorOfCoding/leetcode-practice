[
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "longestcommonprefix.app",
        "description": "longestcommonprefix.app",
        "peekOfCode": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        if not strs:\n            print(\"\")\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    print(\"\")",
        "detail": "longestcommonprefix.app",
        "documentation": {}
    },
    {
        "label": "solucao",
        "kind": 5,
        "importPath": "longestcommonprefix.app",
        "description": "longestcommonprefix.app",
        "peekOfCode": "solucao = Solution()\nresultado = solucao.longestCommonPrefix(['map', 'mop', 'map'])\nprint(resultado)\n#1 - Pegar os digitos da palavra toda",
        "detail": "longestcommonprefix.app",
        "documentation": {}
    },
    {
        "label": "resultado",
        "kind": 5,
        "importPath": "longestcommonprefix.app",
        "description": "longestcommonprefix.app",
        "peekOfCode": "resultado = solucao.longestCommonPrefix(['map', 'mop', 'map'])\nprint(resultado)\n#1 - Pegar os digitos da palavra toda",
        "detail": "longestcommonprefix.app",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "mergetwosortedlists.app",
        "description": "mergetwosortedlists.app",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n         self.val = val\n         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        d = ListNode()\n        cur = d\n        while list1 and list2:\n            if list1.val < list2.val:",
        "detail": "mergetwosortedlists.app",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "mergetwosortedlists.app",
        "description": "mergetwosortedlists.app",
        "peekOfCode": "class Solution(object):\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        d = ListNode()\n        cur = d\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n#solucao = Solution()\n#resultado = solucao.mergeTwoLists()\n#print(resultado)",
        "detail": "mergetwosortedlists.app",
        "documentation": {}
    },
    {
        "label": "#solucao",
        "kind": 5,
        "importPath": "mergetwosortedlists.app",
        "description": "mergetwosortedlists.app",
        "peekOfCode": "#solucao = Solution()\n#resultado = solucao.mergeTwoLists()\n#print(resultado)",
        "detail": "mergetwosortedlists.app",
        "documentation": {}
    },
    {
        "label": "#resultado",
        "kind": 5,
        "importPath": "mergetwosortedlists.app",
        "description": "mergetwosortedlists.app",
        "peekOfCode": "#resultado = solucao.mergeTwoLists()\n#print(resultado)",
        "detail": "mergetwosortedlists.app",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "palindromenumber.app",
        "description": "palindromenumber.app",
        "peekOfCode": "class Solution(object):\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        elif x == 0:\n            return True\n        else:\n            digitos_normais = [int(digito) for digito in str(x)]\n            print(digitos_normais)\n            digitos_invertidos = [int(digito) for digito in str(x)[x::-1]]",
        "detail": "palindromenumber.app",
        "documentation": {}
    },
    {
        "label": "solucao",
        "kind": 5,
        "importPath": "palindromenumber.app",
        "description": "palindromenumber.app",
        "peekOfCode": "solucao = Solution()\nresultado = solucao.isPalindrome(656)\nprint(resultado)",
        "detail": "palindromenumber.app",
        "documentation": {}
    },
    {
        "label": "resultado",
        "kind": 5,
        "importPath": "palindromenumber.app",
        "description": "palindromenumber.app",
        "peekOfCode": "resultado = solucao.isPalindrome(656)\nprint(resultado)",
        "detail": "palindromenumber.app",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "romantointeger.app",
        "description": "romantointeger.app",
        "peekOfCode": "class Solution(object):\n    def romanToInt(self, s):\n        soma = 0\n        hashmap = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        for i in range(len(s) - 1):\n            if hashmap[s[i]] < hashmap[s[i + 1]]:\n                soma -= hashmap[s[i]]\n            else:\n                soma += hashmap[s[i]]\n        soma += hashmap[s[-1]]",
        "detail": "romantointeger.app",
        "documentation": {}
    },
    {
        "label": "solucao",
        "kind": 5,
        "importPath": "romantointeger.app",
        "description": "romantointeger.app",
        "peekOfCode": "solucao = Solution()\nresultado = solucao.romanToInt('MCMXCIV')\nprint(resultado)\n#:type s: str\n#:rtype: int",
        "detail": "romantointeger.app",
        "documentation": {}
    },
    {
        "label": "resultado",
        "kind": 5,
        "importPath": "romantointeger.app",
        "description": "romantointeger.app",
        "peekOfCode": "resultado = solucao.romanToInt('MCMXCIV')\nprint(resultado)\n#:type s: str\n#:rtype: int",
        "detail": "romantointeger.app",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "twosum.app",
        "description": "twosum.app",
        "peekOfCode": "class Solution(object): #hashMap\n    def twoSum(self, nums, target):\n        hashmap = {}\n        for i, num in enumerate(nums):\n            diff = target - num\n            if diff in hashmap:\n                return [hashmap[diff], i]\n            hashmap[num] = i\nsolucao = Solution()\nresultado = solucao.twoSum([2, 4, 6, 2, 5], 6)",
        "detail": "twosum.app",
        "documentation": {}
    },
    {
        "label": "solucao",
        "kind": 5,
        "importPath": "twosum.app",
        "description": "twosum.app",
        "peekOfCode": "solucao = Solution()\nresultado = solucao.twoSum([2, 4, 6, 2, 5], 6)\nprint(resultado)",
        "detail": "twosum.app",
        "documentation": {}
    },
    {
        "label": "resultado",
        "kind": 5,
        "importPath": "twosum.app",
        "description": "twosum.app",
        "peekOfCode": "resultado = solucao.twoSum([2, 4, 6, 2, 5], 6)\nprint(resultado)",
        "detail": "twosum.app",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "validparentheses.app",
        "description": "validparentheses.app",
        "peekOfCode": "class Solution(object):\n    def isValid(self, s):\n        hashmap = {\n            '(': ')',\n            '[': ']',\n            '{': '}'\n        }\n        stack = []\n        for char in s:\n            if char in hashmap:",
        "detail": "validparentheses.app",
        "documentation": {}
    },
    {
        "label": "solucao",
        "kind": 5,
        "importPath": "validparentheses.app",
        "description": "validparentheses.app",
        "peekOfCode": "solucao = Solution()\nresultado = solucao.isValid('()[]')\nprint(resultado)\n#limite: ()[]{}\n#formatos válidos (), [], {}, ([{}])\n#Os parenteses so sao validos quando fechados por ele mesmos (o inicio fecha o final\n#Solucao: Verificar se o primeiro parenteses é igual ao ultimo parenteses (signifca que foi fechado pelo mesmo parenteses)",
        "detail": "validparentheses.app",
        "documentation": {}
    },
    {
        "label": "resultado",
        "kind": 5,
        "importPath": "validparentheses.app",
        "description": "validparentheses.app",
        "peekOfCode": "resultado = solucao.isValid('()[]')\nprint(resultado)\n#limite: ()[]{}\n#formatos válidos (), [], {}, ([{}])\n#Os parenteses so sao validos quando fechados por ele mesmos (o inicio fecha o final\n#Solucao: Verificar se o primeiro parenteses é igual ao ultimo parenteses (signifca que foi fechado pelo mesmo parenteses)",
        "detail": "validparentheses.app",
        "documentation": {}
    }
]